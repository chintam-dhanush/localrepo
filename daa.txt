matrix chain multiplication---------------------------------------------------------------------------
package week_6;
//to run this program navigate to 
// PS D:\2-2_daa_programming> javac  week_6/MatrixChainMultiplication.java
// PS D:\2-2_daa_programming> java -cp . week_6.MatrixChainMultiplication

import java.util.Scanner;

public class MatrixChainMultiplication {
    static final int INFY = 999999999; // Increase INFY to avoid incorrect min calculations
    static long[][] m = new long[20][20];
    static int[][] s = new int[20][20];
    static int[] p = new int[21]; // Increase size to store n+1 values
    static int n;

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int i, j, k;

        System.out.print("Enter the number of matrices: ");
        n = scanner.nextInt();

        // Initialize m[][] and s[][] correctly
        for (i = 1; i <= n; i++)
            m[i][i] = 0;

        System.out.println("\nEnter the dimensions:");
        for (k = 0; k <= n; k++) {  // Loop should run from 0 to n
            System.out.printf("P%d: ", k);
            p[k] = scanner.nextInt();
        }

        matMultiply();

        System.out.println("\nCost Matrix M:");
        for (i = 1; i <= n; i++) {
            for (j = i; j <= n; j++)
                System.out.printf("m[%d][%d]: %d\n", i, j, m[i][j]);
        }

        System.out.println("\nMatrix S for k values:");
        for (i = 1; i <= n; i++) {
            for (j = i; j <= n; j++)
                System.out.printf("s[%d][%d]: %d\n", i, j, s[i][j]);
        }

        System.out.print("\nMULTIPLICATION SEQUENCE: ");
        printOptimal(1, n);
    }

    static void printOptimal(int i, int j) {
        if (i == j)
            System.out.printf("A%d", i);
        else {
            System.out.print("(");
            printOptimal(i, s[i][j]);
            printOptimal(s[i][j] + 1, j);
            System.out.print(")");
        }
    }

    static void matMultiply() {
        int i, j, k, L;
        long q;

        // Fill the table using bottom-up DP
        for (L = 2; L <= n; L++) {  // L is chain length
            for (i = 1; i <= n - L + 1; i++) {
                j = i + L - 1;
                m[i][j] = INFY;

                for (k = i; k < j; k++) {
                    q = m[i][k] + m[k + 1][j] + (long) p[i - 1] * p[k] * p[j];
                    if (q < m[i][j]) {
                        m[i][j] = q;
                        s[i][j] = k;
                    }
                }
            }
        }
    }
}


knapsack----------------------------------------------------------------------
package week_7;
 //to execute:
//  PS D:\2-2_daa_programming> javac  week_7/Knapsack.java
// PS D:\2-2_daa_programming> java -cp . week_7/Knapsack
import java.util.Scanner;
		 
public class Knapsack
{
    static int max(int a, int b) 
    { 
        return (a > b)? a : b; 
    }
    static int knapSack(int W, int wt[], int val[], int n)
    {
        int i, w;
        int [][]K = new int[n+1][W+1];
    
        // Build table K[][] in bottom up manner
        for (i = 0; i <= n; i++)
        {
            for (w = 0; w <= W; w++)
            {
                if (i==0 || w==0)
                    K[i][w] = 0;
                else if (wt[i-1] <= w)
                    K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]],  K[i-1][w]);
                else
                    K[i][w] = K[i-1][w];
            }
        }
    
        return K[n][W];
    }
    
public static void main(String args[])
    {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter the number of items: ");
        int n = sc.nextInt();
        System.out.println("Enter the items weights: ");
        int []wt = new int[n];
        for(int i=0; i<n; i++)
            wt[i] = sc.nextInt();
    
        System.out.println("Enter the items values: ");
        int []val = new int[n];
        for(int i=0; i<n; i++)
            val[i] = sc.nextInt();
    
        System.out.println("Enter the maximum capacity: ");
                int W = sc.nextInt();	 
        
                    System.out.println("The maximum value that can be put in a knapsack of capacity W  is: " + 
                    knapSack(W, wt, val, n));
    sc.close();
    }
}

optimal binary search tree normal---------------------------------------------------
package week_8;
//to implement this do
//PS D:\2-2_daa_programming> javac  .\week_8\obst.java
//PS D:\2-2_daa_programming> java -cp .  week_8.obst
import java.util.Scanner;

public class obst {

    public static int optimalSearchTree(int[] keys, int[] freq, int n) {
        int[][] cost = new int[n][n];

        for (int i = 0; i < n; i++)
            cost[i][i] = freq[i];

        for (int L = 2; L <= n; L++) {
            for (int i = 0; i <= n - L; i++) {
                int j = i + L - 1;
                cost[i][j] = Integer.MAX_VALUE;

                int sum = 0;
                for (int k = i; k <= j; k++)
                    sum += freq[k];

                for (int r = i; r <= j; r++) {
                    int c = 0;
                    if (r > i)
                        c += cost[i][r - 1];
                    if (r < j)
                        c += cost[r + 1][j];
                    c += sum;

                    if (c < cost[i][j])
                        cost[i][j] = c;
                }
            }
        }

        return cost[0][n - 1];
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.print("Enter number of keys: ");
        int n = sc.nextInt();

        int[] keys = new int[n];
        int[] freq = new int[n];

        System.out.println("Enter keys in sorted order:");
        for (int i = 0; i < n; i++) {
            keys[i] = sc.nextInt();
        }

        System.out.println("Enter frequency for each key:");
        for (int i = 0; i < n; i++) {
            freq[i] = sc.nextInt();
        }

        int minCost = optimalSearchTree(keys, freq, n);
        System.out.println("Minimum cost of OBST is: " + minCost);

        sc.close();
    }
}
  optimal binary search tree dynamic programming-----------------------------------------
  package week_8;
//to implement this do
//PS D:\2-2_daa_programming> javac  .\week_8\OPtimal_BST_DP.java
// PS D:\2-2_daa_programming> java -cp .  week_8.OPtimal_BST_DP 
public class OPtimal_BST_DP {

    // Function to calculate the cost of the Optimal BST using dynamic programming
    static int optimalSearchTree(int keys[], int freq[], int n) {
        // Create a 2D table to store the results of subproblems
        int[][] cost = new int[n][n];

        // For a single key, the cost is equal to its frequency
        for (int i = 0; i < n; i++) {
            cost[i][i] = freq[i];
        }

        // L is the chain length (number of keys in the subtree)
        for (int L = 2; L <= n; L++) {
            for (int i = 0; i <= n - L; i++) {
                int j = i + L - 1; // Ending index of the chain
                cost[i][j] = Integer.MAX_VALUE;

                // Calculate the sum of frequencies for keys[i..j]
                int freqSum = sum(freq, i, j);

                // Try making each key in keys[i..j] the root
                for (int r = i; r <= j; r++) {
                    // Cost when keys[r] is the root
                    int leftCost = (r > i) ? cost[i][r - 1] : 0;
                    int rightCost = (r < j) ? cost[r + 1][j] : 0;
                    int totalCost = leftCost + rightCost + freqSum;

                    // Update the minimum cost
                    if (totalCost < cost[i][j]) {
                        cost[i][j] = totalCost;
                    }
                }
            }
        }

        // The final result is stored in cost[0][n-1]
        return cost[0][n - 1];
    }

    // Utility function to calculate the sum of frequencies from index i to j
    static int sum(int freq[], int i, int j) {
        int s = 0;
        for (int k = i; k <= j; k++) {
            s += freq[k];
        }
        return s;
    }

    public static void main(String[] args) {
        int keys[] = {10, 12, 20};
        int freq[] = {34, 8, 50};
        int n = keys.length;

        System.out.println("Cost of Optimal BST is " + optimalSearchTree(keys, freq, n));
    }
}

sum of subsets----------------------------------------------------------------
package week_9;
//to implement this do
//PS D:\2-2_daa_programming> javac  .\week_9\SumOfSubsets.java
////PS D:\2-2_daa_programming> java -cp .  week_9.SumOfSubsets
import java.util.Scanner;
import java.util.Arrays;

public class SumOfSubsets {

    static int[] w;
    static int[] x;
    static int m;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // Input number of elements
        System.out.print("Enter number of elements: ");
        int n = sc.nextInt();

        // Input array elements
        w = new int[n];
        System.out.println("Enter " + n + " positive integers in any order:");
        for (int i = 0; i < n; i++) {
            w[i] = sc.nextInt();
        }

        // Sort weights
        Arrays.sort(w);

        // Input target sum
        System.out.print("Enter the target sum: ");
        m = sc.nextInt();

        // Initialize x[]
        x = new int[n];

        // Calculate total sum of weights
        int total = 0;
        for (int num : w) {
            total += num;
        }

        if (w[0] <= m && total >= m) {
            System.out.println("Subsets that sum to " + m + ":");
            SumOfSub(0, 0, total);
        } else {
            System.out.println("No solution possible");
        }

        sc.close();
    }

    static void SumOfSub(int s, int k, int r) {
        x[k] = 1; // include w[k]

        if (s + w[k] == m) {
            // subset found, print it
            for (int i = 0; i <= k; i++) {
                if (x[i] == 1) {
                    System.out.print(w[i] + " ");
                }
            }
            System.out.println();
        } else if (k + 1 < w.length && s + w[k] + w[k + 1] <= m) {
            // generate left child
            SumOfSub(s + w[k], k + 1, r - w[k]);
        }

        // generate right child
        if (k + 1 < w.length && (s + r - w[k] >= m) && (s + w[k + 1] <= m)) {
            x[k] = 0;
            SumOfSub(s, k + 1, r - w[k]);
        }
    }
}

subset sum---------------------------------------------------------
package week_9;
//to implement this do
//PS D:\2-2_daa_programming> javac  .\week_9\SubsetSum.java
//PS D:\2-2_daa_programming> java -cp .  week_9.SubsetSum
import java.util.ArrayList;
import java.util.List;

public class SubsetSum {

    static void findAllSubsets(int[] set, int targetSum, int index, List<Integer> currentSubset, List<List<Integer>> result) {
        // Base case: if the target sum is 0, add a copy of the current subset to the result
        if (targetSum == 0) {
            result.add(new ArrayList<>(currentSubset));
            return;
        }

        // If target becomes negative or all elements are considered
        if (index >= set.length || targetSum < 0) {
            return;
        }

        // Include the current element
        currentSubset.add(set[index]);
        findAllSubsets(set, targetSum - set[index], index + 1, currentSubset, result);

        // Backtrack and exclude the current element
        currentSubset.remove(currentSubset.size() - 1);
        findAllSubsets(set, targetSum, index + 1, currentSubset, result);
    }

    public static void findSubsets(int[] set, int targetSum) {
        List<List<Integer>> result = new ArrayList<>();
        findAllSubsets(set, targetSum, 0, new ArrayList<>(), result);

        if (result.isEmpty()) {
            System.out.println("No subsets found with sum equal to " + targetSum);
        } else {
            System.out.println("Subsets with sum " + targetSum + ":");
            for (List<Integer> subset : result) {
                System.out.println(subset);
            }
        }
    }

    public static void main(String[] args) {
        int[] set = {1, 2, 3, 5, 6, 8, 12};
        int targetSum = 9;
        findSubsets(set, targetSum);
    }
}

N-Queens-------------------------------------------------------------------
package week_10;
import java.util.*;
//this can be implemented using backtracking
//to implement this do
//PS D:\2-2_daa_programming> javac  .\week_10\NQueens.java
//PS D:\2-2_daa_programming> java -cp .  week_10.NQueens
class NQueens {
    static int[][] board;
    static int N;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter value of N");
        N = sc.nextInt();
        board = new int[N][N];
        if (solve(0)) {
            printboard();
        } else {
            System.out.println("No solution");
        }
        sc.close();
    }

    public static boolean solve(int row) {
        if (row == N) {
            return true;
        }
        for (int col = 0; col < N; col++) {
            if (issafe(row, col)) {
                board[row][col] = 1;
                if (solve(row + 1)) {
                    return true;
                }
                board[row][col] = 0;
            }
        }
        return false;
    }

    public static boolean issafe(int row, int col) {
        for (int i = 0; i < row; i++) {
            if (board[i][col] == 1) {
                return false;
            }
        }
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] == 1) {
                return false;
            }
        }
        for (int i = row - 1, j = col + 1; i >= 0 && j < N; i--, j++) {
            if (board[i][j] == 1) {
                return false;
            }
        }
        return true;
    }

    public static void printboard() {
        System.out.println("The board is: ");
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                System.out.print(board[i][j] + " ");
            }
            System.out.println();
        }
        System.out.println("The board in reverse order is: ");
        for(int i=0;i<N;i++){
            for(int j=N-1;j>=0;j--){
                System.out.print(board[i][j]+" ");
            }
            System.out.println();
        }
    }
}

hamiltonian cycle--------------------------------------------------------------
package week_11;
//this can be implemented using backtracking
//to implement this do
//PS D:\2-2_daa_programming> javac .\week_11\HamiltonianCycle.java
//PS D:\2-2_daa_programming> java -cp . week_11.HamiltonianCycle  
import java.util.Scanner;

public class HamiltonianCycle{

    static int V;
    static int[] path;
    static int[][] graph;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.print("Enter number of vertices: ");
        V = sc.nextInt();

        graph = new int[V][V];
        path = new int[V];

        System.out.println("Enter adjacency matrix:");
        for (int i = 0; i < V; i++)
            for (int j = 0; j < V; j++)
                graph[i][j] = sc.nextInt();

        for (int i = 0; i < V; i++)
            path[i] = -1;
        path[0] = 0;

        if (solve(1))
            printPath();
        else
            System.out.println("No Hamiltonian Cycle exists");

        sc.close();
    }

    static boolean solve(int pos) {
        if (pos == V) {
            return graph[path[pos - 1]][path[0]] == 1;
        }

        for (int v = 1; v < V; v++) {
            if (isSafe(v, pos)) {
                path[pos] = v;
                if (solve(pos + 1))
                    return true;
                path[pos] = -1; // backtrack
            }
        }

        return false;
    }

    static boolean isSafe(int v, int pos) {
        if (graph[path[pos - 1]][v] == 0)
            return false;

        for (int i = 0; i < pos; i++)
            if (path[i] == v)
                return false;

        return true;
    }

    static void printPath() {
        System.out.println("Hamiltonian Cycle:");
        for (int i = 0; i < V; i++)
            System.out.print(path[i] + " ");
        System.out.println(path[0]); // to complete the cycle
    }
}

travelling sales person problem------------------------------------------------------------
package week_12;
// //this can be implemented using backtracking
// //to implement this do
// //PS D:\2-2_daa_programming> javac .\week_12\tspbb.java
// //PS D:\2-2_daa_programming> java -cp . week_12.tspbb
import java.util.Scanner;

public class tspbb {
    static int[][] cost;
    static boolean[] visited;
    static int n, minCost = 9999;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter number of cities: ");
        n = sc.nextInt();

        cost = new int[n][n];
        visited = new boolean[n];

        System.out.println("Enter cost matrix:");
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                cost[i][j] = sc.nextInt();

        visited[0] = true; // start from city 0
        tsp(0, 1, 0);
        System.out.println("Minimum cost: " + minCost);
    }

    static void tsp(int curr, int count, int total) {
        if (count == n && cost[curr][0] > 0) {
            total += cost[curr][0];
            if (total < minCost)
                minCost = total;
            return;
        }

        for (int i = 0; i < n; i++) {
            if (!visited[i] && cost[curr][i] > 0) {
                visited[i] = true;
                tsp(i, count + 1, total + cost[curr][i]);
                visited[i] = false;
            }
        }
    }
}
matMultiply-----------------------------------------------------------------------------------------
import java.util.*;

public class MatrixChain {

    static int[][] s = new int[20][20];

    static void matrix(int p[],int n)
    {
        int m[][] = new int[n][n];
        for(int i=1;i<n;i++)
           m[i][i] = 0;
        for(int l=2;l<n;l++)
        {
            for(int i=1;i<n-l+1;i++)
            {
                int j = i+l-1;
                m[i][j] = Integer.MAX_VALUE;
                for(int k=i;k<j;k++)
                {
                    int q = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j];
                    if(q<m[i][j])
                    {
                        m[i][j] = q;
                        s[i][j] = k;
                    }
                }
            }
        }
        System.out.println("Min multiplications:"+m[1][n-1]);
    }

      static void printOptimal(int i, int j) {
        if (i == j)
            System.out.printf("A%d", i);
        else {
            System.out.print("(");
            printOptimal(i, s[i][j]);
            printOptimal(s[i][j] + 1, j);
            System.out.print(")");
        }
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter no of matrices");
        int n = sc.nextInt();
        int p[] = new int[n+1];
        System.out.println("Enter dimensions");
        for(int i=0;i<n+1;i++)
           p[i] = sc.nextInt();
        matrix(p,n+1);

        System.out.print("\nMULTIPLICATION SEQUENCE: ");
        printOptimal(1, n);
        sc.close();
    }
}
knapSack---------------------------------------------------------------------------------------------------------------------
import java.lang.Math;
import java.util.Scanner;
import java.util.ArrayList;

public class Knapsack {
    static int knapSack(int W, int wt[], int val[], int n) {
        int i, w;
        int [][]K = new int[n+1][W+1];

        // Build table K[][] in bottom up manner
        for (i = 0; i <= n; i++) {
            for (w = 0; w <= W; w++) {
                if (i==0 || w==0)
                    K[i][w] = 0;
                else if (wt[i-1] <= w)
                    K[i][w] = Math.max(val[i-1] + K[i-1][w-wt[i-1]],  K[i-1][w]);
                else
                    K[i][w] = K[i-1][w];
            }
        }

        // Trace selected items
        w = W;
        ArrayList<Integer> selectedItems = new ArrayList<>();
        for (i = n; i > 0 && w > 0; i--) {
            if (K[i][w] != K[i-1][w]) {
                selectedItems.add(i-1);  // Item index
                w = w - wt[i-1];
            }
        }

        System.out.println("Selected item indices (0-based): " + selectedItems);
        System.out.println("Selected item weights and values:");
        for (int idx : selectedItems) {
            System.out.println("Weight: " + wt[idx] + ", Value: " + val[idx]);
        }

        return K[n][W];
    }

    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter the number of items: ");
        int n = sc.nextInt();

        System.out.println("Enter the items weights: ");
        int []wt = new int[n];
        for(int i = 0; i < n; i++)
            wt[i] = sc.nextInt();

        System.out.println("Enter the items values: ");
        int []val = new int[n];
        for(int i = 0; i < n; i++)
            val[i] = sc.nextInt();

        System.out.println("Enter the maximum capacity: ");
        int W = sc.nextInt();

        int maxVal = knapSack(W, wt, val, n);
        System.out.println("The maximum value that can be put in a knapsack of capacity " + W + " is: " + maxVal);
        sc.close();
    }
}
optimalSearchTree----------------------------------------------------------------------------------------------------------------------
import java.util.*;

public class OBSTa {
    static int n;
    static int p[],q[],c[][],r[][],w[][];
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter no of nodes");
        n = sc.nextInt();
        p = new int[n+1];
        q = new int[n+1];
        System.out.println("Enter successful probabilities");
        for(int i=1;i<=n;i++)
           p[i] = sc.nextInt();
        System.out.println("Enter unsuccessful probabilities");
        for(int i=0;i<=n;i++)
           q[i] = sc.nextInt();
        c = new int[n+2][n+2];
        r = new int[n+2][n+2];
        w = new int[n+2][n+2];

        optimal();

        System.out.println("Minimum cost:"+c[0][n]);
        sc.close();
    }

    static void optimal()
    {
        for(int i=0;i<n;i++)
        {
            w[i][i] = q[i];
            c[i][i] = 0;
            r[i][i] = 0;

            w[i][i+1] = q[i] + q[i+1] + p[i+1];
            r[i][i+1] = i + 1;
            c[i][i+1] = q[i] + q[i+1] + p[i+1];
        }
        w[n][n] = q[n];
        r[n][n] = 0;
        c[n][n] = 0;
        for(int m=2;m<=n;m++)
        {
            for(int i=0;i<=n-m;i++)
            {
                int j = i + m;
                w[i][j] = w[i][j-1] + p[j] + q[j];
                int k = find(i,j);
                c[i][j] = w[i][j] + c[i][k-1] + c[k][j];
                r[i][j] = k;
            }
        }
    }

    static int find(int i,int j)
    {
        int min = Integer.MAX_VALUE;
        int l = 0;
        for(int m = r[i][j-1];m<=r[i+1][j];m++)
        {
            if(c[i][m-1]+c[m][j]<min)
            {
                min = c[i][m-1] + c[m][j];
                l = m;
            }
        }
        return l;
    }
}
sumofsubsets---------------------------------------------------------------------------------------------------------
import java.util.*;

public class sumofsubsetsa {

    static void subsets(int s, int r, int k, int w[], int m, int x[]) {
        if (k >= w.length) return; // base case to avoid out of bounds

        x[k] = 1;
        if (s + w[k] == m) {
            // print subset using x[]
            for (int i = 0; i <= k; i++) {
                if (x[i] == 1)
                    System.out.print(w[i] + " ");
            }
            System.out.println();
        } else if (s + w[k] + (k + 1 < w.length ? w[k + 1] : 0) <= m) {
            subsets(s + w[k], r - w[k], k + 1, w, m, x);
        }

        if ((s + r - w[k]) >= m && (k + 1 < w.length && s + w[k + 1] <= m)) {
            x[k] = 0;
            subsets(s, r - w[k], k + 1, w, m, x);
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter no of elements");
        int n = sc.nextInt();

        System.out.println("Enter target sum");
        int m = sc.nextInt();

        int w[] = new int[n];
        int r = 0;
        System.out.println("Enter weight array elements");
        for (int i = 0; i < n; i++) {
            w[i] = sc.nextInt();
            r += w[i];
        }

        Arrays.sort(w); // Required for bounding conditions to work correctly
        int x[] = new int[n];

        System.out.println("Subsets whose sum is " + m + ":");
        subsets(0, r, 0, w, m, x);
        sc.close();
    }
}
nquuens-----------------------------------------------------------------------------------------------------------------
import java.util.*;

public class NQueensa
{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter no of queens");
        int n = sc.nextInt();
        int x[] = new int[n];
        int k = 0;
        nq(k,n,x);
        sc.close();
    }

    static void nq(int k,int n,int x[])
    {
        for(int i=0;i<n;i++)
        {
            if(Place(k,i,n,x))
            {
                x[k] = i;
                if(k==n-1)
                {
                    for(int j=0;j<n;j++)
                    {
                        System.out.print(x[j]+" ");
                    }
                    System.out.println();
                }
                else
                {
                    nq(k+1,n,x);
                }
            }
        }
    }

    static boolean Place(int k,int i,int n,int x[])
    {
        for(int j=0;j<k;j++)
        {
            if(x[j]==i || (Math.abs(x[j]-i)==Math.abs(j-k)))
            {
                return false;
            }
        }
        return true;
    }
}
ham---------------------------------------------------------------------------------------------------------------------------

import java.util.*;

public class HamiltonianPathBookStyle {
    static int[][] G;
    static int[] x;
    static int n;
    static boolean found = false;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt(); // Number of vertices
        int m = sc.nextInt(); // Number of edges

        G = new int[n][n]; // 0-based indexing
        x = new int[n];

        for (int i = 0; i < m; i++) {
            int u = sc.nextInt();
            int v = sc.nextInt();
            G[u][v] = 1;
            G[v][u] = 1;
        }

        for (int start = 0; start < n; start++) {
            Arrays.fill(x, -1); // -1 means unvisited
            found = false;
            x[0] = start;
            hamiltonian(1);
            if (found) {
                System.out.println("YES");
                System.out.print("Path: ");
                for (int i = 0; i < n; i++) {
                    System.out.print(x[i] + " ");
                }
                System.out.println();
                sc.close();
                return;
            }
        }

        System.out.println("NO");
        sc.close();
    }

    static void hamiltonian(int k) {
        do {
            nextValue(k);
            if (x[k] == -1)
                return;
            if (k == n - 1) {
                found = true;
                return;
            } else {
                hamiltonian(k + 1);
            }
        } while (!found);
    }

    static void nextValue(int k) {
        for (int v = 0; v < n; v++) {
            if (G[x[k - 1]][v] == 1 && !isUsed(v, k)) {
                x[k] = v;
                return;
            }
        }
        x[k] = -1; // No valid value found
    }

    static boolean isUsed(int v, int k) {
        for (int i = 0; i < k; i++) {
            if (x[i] == v)
                return true;
        }
        return false;
    }
}

prims--------------------------------------------------------------------------------------

import java.util.Scanner;

public class simple {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.close();

        // Input number of vertices
        System.out.print("Enter number of vertices: ");
        int V = sc.nextInt();

        // Input adjacency matrix
        int[][] graph = new int[V][V];
        System.out.println("Enter the adjacency matrix (0 if no edge): ");
        for (int i = 0; i < V; i++) {
            for (int j = 0; j < V; j++) {
                graph[i][j] = sc.nextInt();
            }
        }

        // Call Prim's algorithm
        primMST(graph, V);
    }

    static void primMST(int[][] graph, int V) {
        int[] key = new int[V];           // Store minimum weights
        boolean[] mstSet = new boolean[V]; // Track included vertices
        int[] parent = new int[V];        // To store MST

        // Initialize all keys as infinite
        for (int i = 0; i < V; i++) {
            key[i] = Integer.MAX_VALUE;
            mstSet[i] = false;
        }

        key[0] = 0;       // Start from first vertex
        parent[0] = -1;   // First node is always the root of MST

        for (int count = 0; count < V - 1; count++) {
            int u = minKey(key, mstSet, V);
            mstSet[u] = true;

            for (int v = 0; v < V; v++) {
                if (graph[u][v] != 0 && !mstSet[v] && graph[u][v] < key[v]) {
                    parent[v] = u;
                    key[v] = graph[u][v];
                }
            }
        }

        printMST(parent, graph, V);
    }

    static int minKey(int[] key, boolean[] mstSet, int V) {
        int min = Integer.MAX_VALUE, minIndex = -1;

        for (int v = 0; v < V; v++) {
            if (!mstSet[v] && key[v] < min) {
                min = key[v];
                minIndex = v;
            }
        }

        return minIndex;
    }

    static void printMST(int[] parent, int[][] graph, int V) {
        int cost = 0;
        System.out.println("Edge \tWeight");
        for (int i = 1; i < V; i++) {
            System.out.println((parent[i] + 1) + " - " + (i + 1) + "\t" + graph[i][parent[i]]);
            cost += graph[i][parent[i]];
        }
        System.out.println("Minimum cost of MST: " + cost);
    }
}
kru------------------------------------------------------------------------------------------------------------------------------------
import java.util.*;

class edge {
    int u;
    int v;
    int w;

    public edge(int u, int v, int w) {
        this.u = u;
        this.v = v;
        this.w = w;
    }

    public String toString() {
        return "Edge(" + u + " - " + v + ") with weight " + w;
    }

}

public class kruskal {

    static int[] p;
    static int n;
    static int e;
    // kruskal(int v)
    // {
    // n=v;
    // p= new int[n+1];
    // for(int i=1;i<=n;i++)
    // p[i]=-1;
    // }

    static int Find(int i) {
        while (p[i] != -1)
            i = p[i];
        return i;
    }

    boolean sameSet(int i, int j) {
        if (Find(i) == Find(j))
            return true;
        else
            return false;

    }

    static void SimpleUnion(int i, int j) {
        p[i] = j;
    }


    static void kru(edge[] edges) {
        int min = 0;
        int c=0;
        int j, k;
        for (int i = 0; i < edges.length; i++) {
            j = edges[i].u;
            k = edges[i].v;
          
            if (Find(j) != Find(k)) {
                c++;
                SimpleUnion(Find(j),Find(k));
                System.out.println(edges[i]);
                min += edges[i].w;

            }
            if(c==n-1){
                break;
            }

        }
        System.out.println("min cost:"+min);

    }

    public static void main(String args[]) {
        System.out.println("enter no of vertices:");
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();

        System.out.println("enter no of edge:");
        e = sc.nextInt();

        edge[] edges = new edge[e];

        for (int i = 0; i < e; i++) {
            int u, v, w;
            System.out.println("enter the edge:"+i+" u/v/weight");
            u = sc.nextInt();
            v = sc.nextInt();
            w = sc.nextInt();

            edges[i] = new edge(u, v, w);

        }

        p = new int[n];
        Arrays.fill(p, -1);

        // edge temp;
        // for(int i=0;i<e-1;i++)
        // for(int j=0;j<e-1-i;j++)
        // {
        // if(edges[j].w>edges[j+1].w){
        // temp=edges[j];
        // edges[j]=edges[j+1];
        // edges[j+1]=temp;
        // }

        // }

        Arrays.sort(edges, Comparator.comparingInt(e -> e.w));


        kru(edges);

        // for (edge edge : edges) {
        // System.out.println(edge);
        // }

        sc.close();

    }

}
jobsequncing-----------------------------------------------------------------------------------------------------------------------------------------
import java.util.*;

class Job {
    int id, deadline, profit;

    Job(int id, int deadline, int profit) {
        this.id = id;
        this.deadline = deadline;
        this.profit = profit;
    }
}

public class JobSequencingCStyle {

    public static void jobSequencing(Job[] jobs, int n) {
        // Sort jobs in descending order of profit
        Arrays.sort(jobs, (a, b) -> b.profit - a.profit);

        // Find max deadline
        int maxDeadline = 0;
        for (Job job : jobs) {
            if (job.deadline > maxDeadline)
                maxDeadline = job.deadline;
        }

        // Create slots for jobs
        int[] slots = new int[maxDeadline];
        Arrays.fill(slots, -1);  // -1 means slot is empty

        int totalProfit = 0;

        for (Job job : jobs) {
            // Try to place the job in the latest available slot before its deadline
            for (int j = job.deadline - 1; j >= 0; j--) {
                if (slots[j] == -1) {
                    slots[j] = job.id;
                    totalProfit += job.profit;
                    break;
                }
            }
        }

        System.out.print("Selected job sequence: ");
        for (int id : slots) {
            if (id != -1)
                System.out.print("J" + id + " ");
        }
        System.out.println("\nTotal Profit: " + totalProfit);
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.print("Enter the number of jobs: ");
        int n = sc.nextInt();

        Job[] jobs = new Job[n];

        System.out.println("Enter job details (ID Deadline Profit):");
        for (int i = 0; i < n; i++) {
            int id = sc.nextInt();
            int deadline = sc.nextInt();
            int profit = sc.nextInt();
            jobs[i] = new Job(id, deadline, profit);
        }

        jobSequencing(jobs, n);

        sc.close();
    }
}
inorder-------------------------------------------------------------------------------------------------------------------------------------------------------
import java.util.Stack;

class Node {
    int data;
    Node left, right;

    Node(int item) {
        data = item;
        left = right = null;
    }
}

public class InorderIterative {

    // Function for iterative inorder traversal
    void inorderTraversal(Node root) {
        Stack<Node> stack = new Stack<>();
        Node current = root;

        while (current != null || !stack.isEmpty()) {
            // Reach the leftmost node of the current node
            while (current != null) {
                stack.push(current);
                current = current.left;
            }

            // Current must be null at this point
            current = stack.pop();
            System.out.print(current.data + " ");

            // Visit the right subtree
            current = current.right;
        }
    }

    public static void main(String[] args) {
        InorderIterative tree = new InorderIterative();

        // Creating a sample binary tree:
        //        1
        //       / \
        //      2   3
        //     / \
        //    4   5

        Node root = new Node(1);
        root.left = new Node(2);
        root.right = new Node(3);
        root.left.left = new Node(4);
        root.left.right = new Node(5);

        System.out.println("Inorder traversal (non-recursive):");
        tree.inorderTraversal(root);
    }
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------
